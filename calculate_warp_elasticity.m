function [dtw_distances, warp_deviation, warp_elasticity] = calculate_warp_elasticity(subTcs, win_size, order, Fpass, Fstop, TR)
    % Computes the warp elasticity between all pairs of signals (i.e. brain
    % networks) across multiple subjects 
    %  
    % Inputs:
    % 1. subTcs    - The fMRI time series across subjects/individuals (Subject by Time by Component)
    % 2. win_size  - The maximum allowable window for the DTW algorithm
    % 3. order     - Filter order for the derivative filter 
    % (Here, we compute the derivate using a derivative filter 
    % to minimize noise introduction)
    % 4. Fpass     - Low cutoff frequency for derivative filter
    % 5. Fstop     - High cutoff frequency for derivate filter
    % 6. TR        - sampling rate of the time series (i.e., Tr in fMRI)
    % 7. t         - time vector 
    %
    % Outputs:
    % 1. dtw_distances - The distance cost of alignment from DTW pairwise
    % computation (Subject by Component by Component)
    % 2. warp_deviation - The warp deviation of each pairwise compution of fMRI signals
    % (Subject by Time by Component by Component)
    % 2. warp_elasticity - The warp elasticy of each pairwise compution of fMRI signals
    % (Subject by [Time - order] by Component by Component)
    %  
    % Examples: 
    %   Here 10 time series are generated by drawing samples from a normal
    %   distribution for 10 Subjects. Asumming a TR of 1 second and filter band of 0.01hz to 0.15hz 
    %  
    %   subTcs = randn(10,1000,10);
    %   win_size = 45;
    %   order = 16;
    %   Fpass = 0.12;
    %   Fstop = 0.15;
    %   TR = 1;
    %   [dtw_distances, warp_deviation, warp_elasticity] = calculate_warp_elasticity(subTcs, win_size, order, Fpass, Fstop, TR)

    [S, T, C]  = size(subTcs);
    srate = 1/TR;

    t = (0:1/srate:((TR*T)-1/srate))'; % Time vector

    % Initialization of outputs
    warp_deviation = zeros(S, T, C, C);
    dtw_distances = zeros(S, C, C);
    warp_elasticity = zeros(S, T-order, C, C);

    % For each subject, compute the pairwise DTW distance, warp elasticity
    % and warp deviation
    for sub_num = 1 : S
        fprintf('sub: %d\n', sub_num)
        for k  = 1 : C
            for i = 1 : C
                x = squeeze(subTcs(sub_num, : , k));
                y = squeeze(subTcs(sub_num, : , i));
                [dtw_distances(sub_num, k, i), ix, iy] = dtw(x, y, win_size);
                % Do linear interpolation to reduce the length back to
                % original after DTW.
                warp_dev = interpolate_tc(ix, T) - interpolate_tc(iy, T);

                warp_deviation(sub_num, :, k, i) = warp_dev;
                warp_elasticity(sub_num, :, k, i) = calc_derivative(warp_dev, order, Fpass, Fstop, srate, t);
            end
        end
    end
end

% Interpolation
function int_tc = interpolate_tc(tc, desired_len)
    tc_len = length(tc);
    x = linspace(1, tc_len, desired_len);
    int_tc = interp1(tc, x, 'linear');
end


function tc_filtered = calc_derivative(tc, Nf, Fpass, Fstop, srate, t)
    d = designfilt('differentiatorfir','FilterOrder',Nf, ...
        'PassbandFrequency',Fpass,'StopbandFrequency',Fstop, ...
        'SampleRate',srate);
    
    dt = t(2)-t(1);
    
    vdrift = filter(d,tc)/dt;
    
    delay = mean(grpdelay(d));

    tc_filtered = vdrift;

    tc_filtered(1:delay) = [];

    tc_filtered(1:delay) = [];
end